#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <fuse.h>
#include <getopt.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <time.h>
#include <unistd.h>
#include <openssl/md5.h>
#include "cloudapi.h"

#include "dedup.h"
#include "extmap.h"
#include "cloudfs.h"

struct file_info {
        char path[MAX_PATH_LEN];
        struct chunk *chunk_list;
        struct file_info *next;
};

struct chunk {
        size_t size;
        char md5[(MD5_DIGEST_LENGTH + 1) * 2];
        struct chunk *next;
};

struct file_info *head_node = NULL;

void print_file_info_list()
{
        printf("++++++++++++++++++++++++++++++++++\n");
        struct file_info *file_info_ptr = head_node;
        while (file_info_ptr) {
                printf("%s\n", file_info_ptr->path);
                print_chunk_list(file_info_ptr->chunk_list);
                printf("----------------------------------\n");
                file_info_ptr = file_info_ptr->next;
        }
        printf("++++++++++++++++++++++++++++++++++\n");
}

void print_chunk_list(struct chunk *chunk_head)
{
        int i = 0;
        while (chunk_head) {
                printf("[%3d] %4d %s\n", i++, chunk_head->size,
                       chunk_head->md5);
                if (i > 44) {
                        printf("");
                }
                chunk_head = chunk_head->next;
        }
}

#define UNUSED __attribute__((unused))

typedef int bool;
#define true 1
#define false 0
#define PATH_MAX 200
#define READ 1
#define WRITE 2
#define CLOSED 0

static struct cloudfs_state state_;
// static StrMap *sm;
static int window_size = 48;
static int avg_seg_size = 4096;
static int min_seg_size = 2048;
static int max_seg_size = 8192;

void fullpath(const char *path, char fpath[])
{
        char p[PATH_MAX];
        strcpy(p, path + 1);
        strcpy(fpath, state_.ssd_path);
        strcat(fpath, p);
        return;
}

int list_bucket(const char *key, time_t modified_time, uint64_t size)
{
        fprintf(stdout, "%s %lu %llu\n", key, modified_time, size);
        return 0;
}

int list_service(const char *bucketName)
{
        fprintf(stdout, "%s\n", bucketName);
        return 0;
}

static FILE *outfile;
int get_buffer(const char *buffer, int bufferLength)
{
        int retval;
        retval = fwrite(buffer, 1, bufferLength, outfile);
        return retval;
}

static FILE *infile;
int put_buffer(char *buffer, int bufferLength)
{
        int retval;
        fprintf(stdout, "put_buffer %d \n", bufferLength);
        retval = fread(buffer, 1, bufferLength, infile);
        return retval;
}

void sanitize(char *path, char tmp[], int size)
{
        char *str_index = path;
        int cnt = 0;
        while (cnt < size) {
                if (*str_index == '/') {
                        tmp[cnt] = '+';
                } else {
                        tmp[cnt] = *str_index;
                }
                str_index++;
                cnt++;
        }
        tmp[size] = '\0';
        return;

}

void desanitize(char *path, char tmp[], int size)
{
        char *str_index = path;
        int cnt = 0;
        while (cnt < size) {
                if (*str_index == '+') {
                        tmp[cnt] = '/';
                } else {
                        tmp[cnt] = *str_index;
                }
                str_index++;
                cnt++;
        }
        tmp[size] = '\0';
        return;
}

static int cloudfs_error(char *error_str)
{
        int retval = -errno;

        // TODO:
        //
        // You may want to add your own logging/debugging functions for printing
        // error messages. For example:
        //
        // debug_msg("ERROR happened. %s\n", error_str, strerror(errno));
        //

        fprintf(stderr, "CloudFS Error: %s\n", error_str);

        /* FUSE always returns -errno to caller (yes, it is negative errno!) */
        return retval;
}

/*
 * Initializes the FUSE file system (cloudfs) by checking if the mount points
 * are valid, and if all is well, it mounts the file system ready for usage.
 *
 */
void *cloudfs_init(struct fuse_conn_info *conn UNUSED)
{
        cloud_init(state_.hostname);
        printf("Create bucket\n");
        cloud_create_bucket("cloudfs");
        printf("Initialize string map\n");
        printf("Initialize head node\n");

        return NULL;
}

void cloudfs_destroy(void *data UNUSED)
{
        cloud_destroy();
}

int cloudfs_utime(const char *path, struct utimbuf *ubuf)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);

        int retstat = 0;
        retstat = utime(fpath, ubuf);
        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_utimens!\n");
        return retstat;
}

int cloudfs_mknod(const char *path, mode_t mode, dev_t dev)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("mknod!\n");
        int retstat = 0;
        if (S_ISREG(mode)) {
                retstat = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
                if (retstat < 0)
                        retstat = cloudfs_error("cloudfs_mknod open");
                else {
                        retstat = close(retstat);
                        if (retstat < 0)
                                retstat = cloudfs_error("cloudfs_mknod close");
                }
        } else if (S_ISFIFO(mode)) {
                retstat = mkfifo(fpath, mode);
                if (retstat < 0)
                        retstat = cloudfs_error("cloudfs_mknod mkfifo");
        } else {
                retstat = mknod(fpath, mode, dev);
                if (retstat < 0)
                        retstat = cloudfs_error("cloudfs_mknod mknod");
        }

        return retstat;
}

int cloudfs_getattr(const char *path, struct stat *statbuf)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("getattr!\n");
        int retstat = 0;
        bool is_proxy = false;
        int retval = lgetxattr(fpath, "user.is_proxy", &is_proxy, sizeof(bool));
        if ((retval >= 0) && (is_proxy)) {  //proxy file, get the stat from xattr
                printf("is proxy\n");
                lgetxattr(fpath, "user.stat", statbuf, sizeof(struct stat));
                printf("getattr proxy file: %d\n", retstat);
                printf("fpath: %s, size %d\n", fpath, statbuf->st_size);
        } else {                //regular file, regular way
                retstat = lstat(fpath, statbuf);
                printf("lstat:%d\n", retstat);
        }
        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_getattr!\n");
        return retstat;
}

int
cloudfs_getxattr(const char *path, const char *name, char *value, size_t size)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("getxattr!\n");
        int retstat = 0;
        retstat = lgetxattr(fpath, name, value, size);
        if (retstat < 0) {
                retstat = cloudfs_error("cloudfs_getxattr!\n");
        }
        return retstat;
}

int
cloudfs_setxattr(const char *path, const char *name, const char *value,
                 size_t size, int flags)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("setxattr!\n");
        int retstat = 0;
        retstat = lsetxattr(fpath, name, value, size, flags);
        if (retstat < 0)
                retstat = cloudfs_error("setxattr!\n");
        return retstat;
}

int cloudfs_mkdir(const char *path, mode_t mode)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("mkdir!\n");
        int retstat = 0;
        retstat = mkdir(fpath, mode);
        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_mkdir!\n");
        return retstat;
}

int cloudfs_rmdir(const char *path)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("rmdir!\n");
        int retstat = 0;
        retstat = rmdir(fpath);
        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_rmdir!\n");
        return retstat;
}

int cloudfs_unlink(const char *path)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("unlink!\n");
        int retstat = 0;
        bool is_proxy = false;
        int retval = lgetxattr(fpath, "user.is_proxy", &is_proxy, sizeof(bool));
        if (retval >= 0 && is_proxy) {  //proxy, delete the file on the cloud as welll
                printf("delete the file on the cloud as well\n");
                int path_len = strlen(fpath);
                char san_path[path_len];
                sanitize(fpath, san_path, path_len);
                printf("cloud delete object: %s\n", san_path);
                cloud_delete_object("cloudfs", san_path);
                cloud_print_error();

        }

        retstat = unlink(fpath);

        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_unlink!\n");
        return retstat;
}

int cloudfs_chmod(const char *path, mode_t mode)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("chmod!\n");
        int retstat = 0;
        retstat = chmod(fpath, mode);
        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_chmod!\n");
        return retstat;
}

int cloudfs_truncate(const char *path, off_t newsize)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("truncate!\n");
        int retstat = 0;
        retstat = truncate(fpath, newsize);
        if (retstat < 0)
                cloudfs_error("truncate!\n");
        return retstat;
}

int cloudfs_release(const char *path, struct fuse_file_info *ffi)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("release!\n");
        int retstat = 0;

        int open_cnt = -1;

        int fd = -1;
        int retval = -1;
        bool is_proxy = false;
        retval = lgetxattr(fpath, "user.is_proxy", &is_proxy, sizeof(bool));
        if (retval > 0 && is_proxy) {
                //if return from read(), unlink the dummy file, return
                int rw = -1;
                retval = lgetxattr(fpath, "user.rw", &rw, sizeof(int));
                if (retval > 0 && rw == READ) {
                        // char dummy_prefix[PATH_MAX] = ".";
                        // strcat(dummy_prefix, fpath);
                        strcat(fpath, "~");
                        unlink(fpath);

                        retstat = close(ffi->fh);

                        return retstat;
                }

                if (retval > 0 && rw == WRITE) {

                }
        }

        retval = lgetxattr(fpath, "user.open_cnt", &open_cnt, sizeof(int));
        printf("getxattr open_cnt retval:%d,open_cnt:%d, path: %s\n", retval,
               open_cnt, fpath);
        if (retval < 0) {
                retstat = close(ffi->fh);

                return retstat;
        }
        open_cnt--;
        printf("read open_cnt successful!\n");
        if (open_cnt == 0) {    //not open in other place
                printf("open_cnt == 0!\n");
                //check if it's a big file or small file
                struct stat statbuf;
                //get the size of the file
                printf("%s\n", fpath);
                int ret = lstat(fpath, &statbuf);
                size_t file_size = 0;
                printf("lstat:%d, errno:%d\n", ret, errno);
                if (ret == 0) { //without error
                        file_size = statbuf.st_size;
                        //printf("get file_size:%d\n", file_size);;
                }
                printf("file_size: %d, state_.threshold:%d\n", file_size,
                       state_.threshold);
                if (file_size > (unsigned int)state_.threshold) {   //big file
                        printf("big file!\n");
                        //upload to cloud
                        //segment, add all the MD5 of its chunks into table
                        rabinpoly_t *rp =
                            rabin_init(window_size, avg_seg_size, min_seg_size,
                                       max_seg_size);
                        if (!rp) {
                                printf("Failed to init rabinhash algorithm\n");
                        }

                        MD5_CTX ctx;
                        unsigned char md5[MD5_DIGEST_LENGTH];
                        int i;
                        for (i = 0; i < MD5_DIGEST_LENGTH; i++) {
                                md5[i] = '\0';
                        }
                        int new_segment = 0;
                        int len, segment_len = 0, b;
                        char buf[8192];
                        int bytes;
                        MD5_Init(&ctx);
                        fd = open(fpath, O_RDWR);
                        // bytes = read(fd, buf, sizeof buf);
                        // printf("read from big file: %d\n", bytes);
                        char chunk_MD5[MD5_DIGEST_LENGTH * 2 + 2];
                        char *chunks[file_size / min_seg_size];
                        int chunk_size[file_size / min_seg_size];
                        int chunk_num = 0;
                        while ((bytes = read(fd, buf, sizeof buf)) > 0) {
                                for (i = 0; i < bytes; i++) {
                                        if ((!isprint(buf[i]))
                                            && (buf[i] != '\n'))
                                                printf("Aou\n");
                                }

                                // printf("read big file?\n");
                                char *buftoread = (char *)&buf[0];
                                while ((len =
                                        rabin_segment_next(rp,
                                                           buftoread +
                                                           segment_len, bytes,
                                                           &new_segment)) > 0) {
                                        MD5_Update(&ctx, buftoread, len);
                                        segment_len += len;
                                        // printf("next segment?\n");1137ab14868

                                        if (new_segment) {
                                                printf("new segment!\n");
                                                MD5_Final(md5, &ctx);
                                                //update the strmap map
                                                //key: MD5; value: dir
                                                for (b = 0;
                                                     b < MD5_DIGEST_LENGTH;
                                                     b++) {
                                                        printf("%02x", md5[b]);
                                                        sprintf(&chunk_MD5
                                                                [b * 2], "%02x",
                                                                md5[b]);
                                                }

                                                chunks[chunk_num] = (char *)
                                                    malloc((MD5_DIGEST_LENGTH *
                                                            2 +
                                                            2) * sizeof(char));
                                                strcpy(chunks[chunk_num],
                                                       chunk_MD5);
                                                chunk_size[chunk_num] =
                                                    segment_len;
                                                chunk_num++;
                                                if (!exist(chunk_MD5)) {
                                                        printf
                                                            ("not exists in strmap!\n");
                                                        insert(chunk_MD5, 1);
                                                }

                                                for (i = 0; i < segment_len;
                                                     i++) {
                                                        if ((!isprint
                                                             (buftoread[i]))
                                                            && (buftoread[i] !=
                                                                '\n'))
                                                                printf("Aou\n");
                                                }

                                                //put the segment onto the cloud, named after MD5
                                                infile =
                                                    fmemopen(buftoread,
                                                             segment_len, "r");

                                                printf("key: %s", chunk_MD5);
                                                printf(" ");
                                                printf("value: %d\n",
                                                       get(chunk_MD5));
                                                cloud_put_object("cloudfs",
                                                                 chunk_MD5,
                                                                 segment_len,
                                                                 put_buffer);
                                                fclose(infile);
                                                //write md5 of every chunk in order into xattr

                                                MD5_Init(&ctx);
                                                buftoread += segment_len;
                                                segment_len = 0;
                                        }

                                        bytes -= len;
                                        if (!bytes && !new_segment) {

                                                printf("new segment!\n");
                                                MD5_Final(md5, &ctx);
                                                //update the strmap map
                                                //key: MD5; value: dir
                                                for (b = 0;
                                                     b < MD5_DIGEST_LENGTH;
                                                     b++) {
                                                        printf("%02x", md5[b]);
                                                        sprintf(&chunk_MD5
                                                                [b * 2], "%02x",
                                                                md5[b]);
                                                }

                                                chunks[chunk_num] = (char *)
                                                    malloc((MD5_DIGEST_LENGTH *
                                                            2 +
                                                            2) * sizeof(char));
                                                strcpy(chunks[chunk_num],
                                                       chunk_MD5);
                                                chunk_size[chunk_num] =
                                                    segment_len;
                                                chunk_num++;
                                                if (!exist(chunk_MD5)) {
                                                        printf
                                                            ("not exists in strmap!\n");
                                                        insert(chunk_MD5, 1);
                                                }
                                                //put the segment onto the cloud, named after MD5
                                                infile =
                                                    fmemopen(buftoread,
                                                             segment_len, "r");
                                                printf("key: %s", chunk_MD5);
                                                printf(" ");
                                                printf("value: %d\n",
                                                       get(chunk_MD5));
                                                cloud_put_object("cloudfs",
                                                                 chunk_MD5,
                                                                 segment_len,
                                                                 put_buffer);
                                                segment_len = 0;
                                                break;
                                        }
                                }
                                if (len == -1) {
                                        printf
                                            ("Failed to process the segment\n");
                                        break;
                                }
                        }
                        MD5_Final(md5, &ctx);

                        // infile = fopen(fpath, "rb");
                        //sanitize the file name on the cloud
                        // int path_len = strlen(fpath);
                        // char san_path[path_len];
                        // sanitize(fpath, san_path, path_len);
                        // printf("san_path:%s\n", san_path);
                        struct stat stat_buf;
                        lstat(fpath, &stat_buf);
                        // cloud_put_object("cloudfs", san_path, stat_buf.st_size, put_buffer);
                        // fclose(infile);
                        //set the extending attribute is_proxy
                        bool is_proxy = true;
                        lsetxattr(fpath, "user.is_proxy", &is_proxy,
                                  sizeof(bool), 0);
                        //save the stat in xattr
                        lsetxattr(fpath, "user.stat", &stat_buf,
                                  sizeof(struct stat), 0);
                        //save MD5 segment information
                        // lsetxattr(fpath, "user.MD5_array", &chunks,sizeof(char *), 0);
                        // lsetxattr(fpath, "user.MD5_array_len", &chunk_num, sizeof(int), 0);
                        //make the local replica proxy, that is, clear the file

                        close(fd);
                        // truncate(fpath, 0);
                        printf("truncate\n");
                        fd = open(fpath, O_RDWR | O_TRUNC);
                        close(fd);
                        FILE *f_md5;
                        f_md5 = fopen(fpath, "w");

                        printf("retval: %d\n", retval);
                        int j;
                        for (j = 0; j < chunk_num; j++) {
                                printf("md5 in release: %s\n", chunks[j]);
                                // retval = write(fd, chunks[j], MD5_DIGEST_LENGTH*2+2);

                                retval =
                                    fprintf(f_md5, "%04d %s\n", chunk_size[j],
                                            chunks[j]);
                                if (retval < 0) {
                                        perror("write:");
                                }
                        }
                        // close(fd);
                        // fd = open(fpath, O_RDWR);
                        for (j = 0; j < chunk_num; j++) {
                                free(chunks[j]);
                        }
                        // for(j=0; j<chunk_num; j++){
                        // read(fd, buffer1, MD5_DIGEST_LENGTH*2+2);
                        // printf("readdddd5: %s\n", buffer1);
                        // }
                        fclose(f_md5);
                }
        }
        // int fd = open(fpath, O_RDWR|O_TRUNC);
        // close(fd);
        retstat = close(ffi->fh);

        return retstat;
}

int cloudfs_open(const char *path, struct fuse_file_info *ffi)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("open!\n");
        int retstat = 0;
        int fd;
        fd = open(fpath, ffi->flags);
        // printf("fd:%d\n", fd);

        //set extend attribute is_proxy and open_cnt
        bool is_proxy = false;
        int retval = lgetxattr(fpath, "user.is_proxy", &is_proxy, sizeof(bool));
        if (retval < 0) {       //no is_proxy attribute, set to default
                is_proxy = false;
                int ret = lsetxattr(fpath, "user.is_proxy", &is_proxy,
                                    sizeof(bool), 0);
                // printf("setxattr is_proxy : %d, is_proxy:%d, path: %s\n", ret, is_proxy, fpath);
        } else {                //valid is_proxy attribute, check if it's a proxy file

                if (is_proxy) { //it's a proxy file, retrieve it from the cloud
                        // printf("retrieve %s from cloud\n", fpath);
                        char *buf[MD5_DIGEST_LENGTH * 2 + 2 + 5];
                        printf("try to read?\n");
                        // while((retval = read(fd, buf, MD5_DIGEST_LENGTH*2 + 2 + 5)) > 0){
                        //   printf("components: %s\n", buf);
                        // }

                        //open a dummy file, than give this fd to read.

                        //populate the chunk list, so read can know which chunk to get.
                        //FIXME check if double opened
                        struct file_info *curr = NULL;
                        if (head_node != NULL) {
                                curr = head_node;
                                while (curr && strcmp(curr->path, fpath)) {
                                        curr = curr->next;
                                }
                        }

                        if (!curr) {
                                curr = (struct file_info *)
                                    malloc(sizeof(struct file_info));
                                curr->next = head_node;
                                head_node = curr;
                        }

                        strcpy(curr->path, fpath);
                        curr->chunk_list = NULL;

                        struct chunk **chunk_ptr;
                        chunk_ptr = &(curr->chunk_list);

                        printf("populate the chunk_list\n");
                        char buffer[5 + (MD5_DIGEST_LENGTH + 1) * 2];
                        while ((retval =
                                read(fd, buffer,
                                     (MD5_DIGEST_LENGTH) * 2 + 1 + 5)) > 0) {
                                *chunk_ptr = (struct chunk *)
                                    malloc(sizeof(struct chunk));
                                (*chunk_ptr)->next = NULL;

                                sscanf(buffer, "%4d %s", &((*chunk_ptr)->size),
                                       (*chunk_ptr)->md5);
                                printf("components: %s\n", (*chunk_ptr)->md5);
                                chunk_ptr = &((*chunk_ptr)->next);
                        }
                } else {        //it's not a proxy file, open it locally
                        //already opened
                        printf("not proxy\n");
                        //give read the real fd:
                }
        }
        int open_cnt = 1;
        retval = lgetxattr(fpath, "open_cnt", &open_cnt, sizeof(int));
        if (retval < 0) {       //no open_cnt attribute, set to default
                open_cnt = 1;
                int setxa_ret = lsetxattr(fpath, "user.open_cnt", &open_cnt,
                                          sizeof(int), 0);
                // printf("setxattr open_cnt complete:%d, path: %s\n", setxa_ret, fpath);
        } else {                //valid open_cnt attribute, increment by 1
                open_cnt++;
                lsetxattr(fpath, "user.open_cnt", &open_cnt, sizeof(int), 0);
        }

        if (fd < 0)
                retstat = cloudfs_error("cloudfs_open!\n");
        ffi->fh = fd;
        return retstat;
}

int
cloudfs_read(const char *path, char *buf, size_t nbyte,
             off_t offset, struct fuse_file_info *ffi)
{
        char fpath[PATH_MAX];
        struct file_info *cur;
        size_t acc_segment_size = 0;
        int dummy_fd;
        fullpath(path, fpath);
        printf("read!\n");
        int rw = READ;
        lsetxattr(fpath, "user.rw", &rw, sizeof(int), 0);
        //use lseek to find the offset, seemed ok so far;
        // lseek(ffi->fh, offset, SEEK_SET);
        bool is_proxy = false;
        int retval = lgetxattr(fpath, "user.is_proxy", &is_proxy, sizeof(bool));
        if (retval < 0) {
                perror("in read, is_proxy not set!\n");
        }
        if (!is_proxy) {
                //local file, no surprise
                // int retstat = read(ffi->fh, buf, nbyte);
                // if(retstat < 0)
                //   retstat = cloudfs_error("cloudfs_read!\n");
                // return retstat;
        } else {
                //get the correct chunks from the cloud and fill into the dummy file
                cur = head_node;
                while (strcmp(cur->path, fpath)) {
                        cur = cur->next;
                }
                struct chunk *chunk_list_index = cur->chunk_list;

                while (1) {
                        if (acc_segment_size + chunk_list_index->size > offset) {
                                break;
                        }
                        acc_segment_size += chunk_list_index->size;
                        chunk_list_index = chunk_list_index->next;
                }

                //now index point to the first chunk we have to fetch
                // FILE* fp = fdopen(fd, "w");

                char dummy_fpath[MAX_PATH_LEN];
                strcpy(dummy_fpath, fpath);
                strcat(dummy_fpath, "~");

                printf("dummy dir:%s\n", dummy_fpath);

                print_file_info_list();

                outfile = fopen(dummy_fpath, "w+");
                fseek(outfile, acc_segment_size, SEEK_SET);
                size_t left_bound = acc_segment_size;

                while (acc_segment_size < (offset + nbyte)) //FIXME!
                {
                        cloud_get_object("cloudfs", chunk_list_index->md5,
                                         get_buffer);
                        if (!chunk_list_index->next) {
                                break;
                        }
                        chunk_list_index = chunk_list_index->next;
                        acc_segment_size += chunk_list_index->size;
                }
                if (outfile) {
                        fclose(outfile);
                        outfile = NULL;
                }
                dummy_fd = open(dummy_fpath, O_RDONLY);
                lseek(dummy_fd, left_bound, SEEK_SET);
                int retstat = read(dummy_fd, buf, nbyte);
                if (retstat < 0)
                        retstat = cloudfs_error("cloudfs_read!\n");
                close(dummy_fd);

                return retstat;
        }

        lseek(dummy_fd, offset, SEEK_SET);
        int retstat = read(ffi->fh, buf, nbyte);
        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_read~\n");
        close(dummy_fd);
        if (outfile) {
                fclose(outfile);
                outfile = NULL;
        }
        return retstat;
}

int
cloudfs_write(const char *path, const char *buf, size_t size,
              off_t offset, struct fuse_file_info *ffi)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("write!\n");
        int rw = WRITE;
        lsetxattr(fpath, "user.rw", &rw, sizeof(int), 0);
        int retstat = 0;
        //use lseek to find the offset, seemed of so far;
        lseek(ffi->fh, offset, SEEK_SET);
        retstat = write(ffi->fh, buf, size);
        if (retstat < 0)
                retstat = cloudfs_error("cloudfs_write!\n");
        return retstat;

}

int cloudfs_readlink(const char *path, char *link, size_t size)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("readlink!\n");
        int retstat = 0;
        retstat = readlink(fpath, link, size - 1);
        if (retstat < 0) {
                retstat = cloudfs_error("readlink!\n");
        } else {
                link[retstat] = '\0';
                retstat = 0;
        }
        return retstat;
}

int cloudfs_opendir(const char *path, struct fuse_file_info *ffi)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("cloudfs_opendir!\n");
        DIR *dp;
        int retstat = 0;
        dp = opendir(fpath);
        if (dp == NULL)
                retstat = cloudfs_error("cloudfs_opendir\n");
        ffi->fh = (intptr_t) dp;

        return retstat;
}

int
cloudfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
                off_t offset, struct fuse_file_info *ffi)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("cloudfs_readdir\n");
        int retstat = 0;
        DIR *dp;
        struct dirent *de;

        dp = (DIR *) (uintptr_t) ffi->fh;
        de = readdir(dp);
        if (de == 0) {
                retstat = cloudfs_error("readdir error!\n");
                return retstat;
        }
        do {
                if (filler(buf, de->d_name, NULL, 0) != 0) {
                        return -ENOMEM;
                }

        }
        while ((de = readdir(dp)) != NULL);
        return retstat;
}

int cloudfs_access(const char *path, int mask)
{
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        printf("access!\n");
        int retstat = 0;
        retstat = access(fpath, mask);
        if (retstat < 0)
                return cloudfs_error("cloudfs_access!\n");
        return retstat;
}

int cloudfs_chown(const char *path, uid_t uid, gid_t gid)
{
        int retstat = 0;
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        retstat = chown(fpath, uid, gid);
        if (retstat < 0) {
                retstat = cloudfs_error("cloudfs_chown!\n");
        }
        return retstat;

}

int cloudfs_create(const char *path, mode_t mode, struct fuse_file_info *ffi)
{
        int retstat = 0;
        char fpath[PATH_MAX];
        fullpath(path, fpath);
        int fd;

        fd = creat(fpath, mode);
        if (fd < 0)
                retstat = cloudfs_error("cloudfs_create!\n");
        ffi->fh = fd;
        return retstat;
}

/*
 * Functions supported by cloudfs 
 */
static struct fuse_operations cloudfs_operations = {
        .init = cloudfs_init,
        //
        // TODO
        //
        // This is where you add the VFS functions that your implementation of
        // MelangsFS will support, i.e. replace 'NULL' with 'melange_operation'
        // --- melange_getattr() and melange_init() show you what to do ...
        //
        // Different operations take different types of parameters. This list can
        // be found at the following URL:
        // --- http://fuse.sourceforge.net/doxygen/structfuse__operations.html
        //
        //
        .getattr = cloudfs_getattr,
        .getxattr = cloudfs_getxattr,
        .setxattr = cloudfs_setxattr,
        .mkdir = cloudfs_mkdir,
        .mknod = cloudfs_mknod,
        .open = cloudfs_open,
        .read = cloudfs_read,
        .write = cloudfs_write,
        .release = cloudfs_release,
        .opendir = cloudfs_opendir,
        .readdir = cloudfs_readdir,
        .access = cloudfs_access,
        .utime = cloudfs_utime,
        .chmod = cloudfs_chmod,
        .unlink = cloudfs_unlink,
        .rmdir = cloudfs_rmdir,
        .destroy = cloudfs_destroy,
        .readlink = cloudfs_readlink,
        .truncate = cloudfs_truncate,
        .chown = cloudfs_chown,
        .create = cloudfs_create
};

int cloudfs_start(struct cloudfs_state *state, const char *fuse_runtime_name)
{

        int argc = 0;
        char *argv[10];
        argv[argc] = (char *)malloc(128 * sizeof(char));
        strcpy(argv[argc++], fuse_runtime_name);
        argv[argc] = (char *)malloc(1024 * sizeof(char));
        strcpy(argv[argc++], state->fuse_path);
        argv[argc++] = "-s";    // set the fuse mode to single thread
        argv[argc++] = "-f";    // run fuse in foreground 

        state_ = *state;
        printf("%d\n", state_.threshold);
        // hello();
        int fuse_stat = fuse_main(argc, argv, &cloudfs_operations, NULL);

        // printf("deleting sm...");
        // sm_delete(sm);
        cloud_destroy();
        return fuse_stat;
}
